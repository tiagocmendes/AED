Notas:

4 cidades:

0,1,2,3
Considerar os seguintes sub-problemas

Caminho mais pequeno
Calcular o tamanho do caminho 
0 - x - x - 1 + d(1,0)
0 - x - x - 2 + d(2,0)
0 - x - x - 3 + d(3,0)

d(0xx1) - como Calcular esta distancia?
d(032) + d(2,1)
d(023) + d(3,1)


s = {0,1,2,...,n-1}

0 pertence ou nao pertence?
.
.
.
n-1 pertence ou nao pertence?

s = {3,7} -> m = (1<<3) + (1<<7)                     1<<3 = 1000 
                                                     1<<7 = 10000000

dmin (0,{1,2,4,5,8},3)
                     |- array[3][mask]

Como calcular esta distância minima?
Subconjunto guardado um inteiro (uns e zeros)

parte recursiva: funcao(recebe valor inicial, valor final, e um subconjunto) usar calloc

se a distancia nao tiver sido calculada, fazer o que esta abaixo. senao, ir apenas ao array
varrer todos os bits das mascara(tirar os que estao a 1)

 = min(
        dmin(0, {2,4,5,8},1) + d(1,3), 
        dmin(0, {1,4,5,8},2) + d(2,3),
        dmin(0, {1,2,5,8},4) + d(4,3),
        dmin(0, {1,2,4,8},5) + d(5,3),
        dmin(0, {1,2,4,5},8) + d(8,3),
        );

Máscaras: 

i pertence a S se (m & (1<<i)) != 0
i nao pertence a S se (m & (1<<i)) == 0


calcular o caminho:
ter um segundo array, que destas escolhas todas, diz quel e que foi usada